## Developed by James O'Malley June 29, 2024 ##

## Step 1 of data wrangling process
## Program to refine concordance analysis of NPO survey nominations and patient-sharing in Medicare ##
## Compares network formed directly from NPO physician claims to that generated by the 20 methods ##
##   in the Python script. ##
##   Confirms that the same result is obtained. ##
## Saves the generated networks for a summarization program (ConcordStatsAllNew.r) to then perform the ##
##   concordance analysis. ##
## The variable uType contains the nomination type (1=InfAdviceOwnHosp, 2=ReferralOwnHosp, 3=InfAdviceOtherHosp,
##   4=ReferralOtherHosp)

library(lme4)
library(foreign)

setwd("/drives/drive1/54054dua/programs/jomalley")
datmeg="../../idata/idata/Phys_Survey/"
datdir="../../idata/jomalley/"
#datdirpy="../../idata/jomalley/PHN-subnetwork/2018/batch-1/"
datdirpy="../../idata/jomalley/PHN-subnetwork/2019/batch-1/" #I recently added this; need to check that actually built network this way!
outdir="../../idata/jomalley/"

source('PatientSharingNew.r') #Loads patient-sharing function (to perform CMS claims network projection)

### Read-in CMS data: list of benes who visited one or both physicians comprising a survey nominated dyad ###

#Read in Part B data (raw claims extracted by Megan from master file)
#  Extract all visits involving responding or nominated physicians that are Part B E&M claims
#  By construction, each bene visits either the responding or the nominated physician

#Data dictionary of CMS data
#Fields currently used:
# line_npi = provider who performed service
# bill_npi = organizational NPI or person who billed for service
# nominee = 1 if nominated physician, 0 if responding physician
# sound_provider = 1 if NPO provider, 0 otherwise
# npi_lkup = 1 if looked up NPI on NPPES?
# BENE_ID = id of bene
# Sthrudt = Start date of service (hospital stay etc)

#Fields not used (dropped in step below):
# ACO_ID_NUM = Accountable care organization ID number?
# PRV_TYPE = Provider type; 2-digit code possibly referring to specialty
# PROVZIP9 = Provider zip-code (9-digits)
# HCFASPCL = Provider specialty code
# TYPSRVCB = Type of service
# PLCSRVC = Place of service
# HCPCS_CD = Health care common procedure code (HICPCS code)
# FWORK_RVU = Relative value unit of service provided to patient

#Script for forming patient-sharing network from CMS claims involving NPO physicians
olddata <- 0
if (olddata==1) {
 data <- read.csv(paste(datdir,"phys_survey_clms18.csv",sep=""),header=TRUE)
 keep <- c("line_npi","nominee","sound_provider","npi_lkup","BENE_ID")

 #Retain useful physician information in a physician attribute file
 # Other physician information obtained from sampling frame file later
 nominee <- tapply(data$nominee,data$line_npi,'mean')
 sound <- tapply(data$sound_provider,data$line_npi,'mean')
 lkup <- tapply(data$npi_lkup,data$line_npi,'mean')
 npi <- names(sound)
 physattr <- data.frame(npi=npi,nominee=nominee,sound=sound,npi_lkup=lkup)
} else {
 data <- read.csv(paste(datmeg,"phys_surv_ptb19sub.csv",sep=""),header=TRUE) 
 data$line_npi <- data$NPI
 keep <- c("BENE_ID","line_npi","STHRUDT")
}
ord <- order(data$BENE_ID)
data <- data[ord,keep]

#Summary information about length of patient referral paths
tmp <- tapply(data$BENE_ID,data$BENE_ID,'length')
summary(tmp)
q <- seq(0,1,0.01)
print(quantile(tmp,q))

#Generate edgelist from CMS (claims) data
usebill <- 0 #Select patients using line vs bill npi (or either). I used line_npi.
edgecms <- makeedgelistdir(data,usebill)
u1 <- unique(edgecms$npi1)
u2 <- unique(edgecms$npi2)
u <- unique(c(u1,u2))
print(c(length(u1),length(u2),length(u)))

#Reduce to edges and associated reverse edges for which we know the true edge status by using the nomination data set
#Read-in survey data based on the file: updated_one_to_one_match.csv
sdata <- read.csv(paste(datdir,"updated_one_one_match.csv",sep=""),header=TRUE)
sdata <- sdata[,c(4:ncol(sdata))]
names(sdata) <- c("nominee","HospNomID","HospRespName","ConnectType","SpecialtyNom","responding")
npiresp <- unique(sdata$responding) #Gets list of physicians who responded to the survey
trueedge <- edgecms[edgecms$npi1 %in% npiresp,]
trueedger <- edgecms[edgecms$npi2 %in% npiresp,]
keepedge <- merge(trueedge,trueedger,by.x=c("npi1","npi2"),by.y=c("npi2","npi1"),suffix=c("","r"))
keepedge <- keepedge[,c("npi1","npi2","upat","upatdir","upatsame","upatdirr","gvisit" )]
print(c(length(unique(keepedge$npi1)),length(unique(keepedge$npi2)),sum(keepedge$npi1==keepedge$npi2)))

#Load 80 weighted networks (loads data derived from phys_survey_clms18.csv or part B files) 
# and reduce edges as above. Note that only the 20 weighted-directed projections used in this work
dataw <- read.csv(paste(datdirpy,"PHN0-anda19.txt",sep=""),header=FALSE,sep=";") #2019 year
dataw <- dataw[,-82]
wtcols <- paste("w",1:80,sep="")
names(dataw) <- c("edgestr",wtcols)
dataw$npi1 <- as.numeric(substr(dataw$edgestr,1,10))
dataw$npi2 <- as.numeric(substr(dataw$edgestr,12,21))
ind <- (dataw$npi1==dataw$npi2)
dataw <- dataw[!ind,]
phnmat <- cbind(dataw$npi1,dataw$npi2)
phnmax <- apply(phnmat,1,'max'); phnmin <- apply(phnmat,1,'min'); 
dataw$dyadidstr <- paste(phnmin,phnmax,sep="_")
dataw <- dataw[order(dataw$dyadidstr),]
dataw <- dataw[,c("npi1","npi2","edgestr","dyadidstr",wtcols)]

#Make dataw complete: fill in reverse edges for undirected weights with same weight
Directed=rep(rep(c(1,0),each=20),times=80/40) #1 = Directed, 0 = Undirected
dataw2 <- data.frame(npi1=dataw$npi2,npi2=dataw$npi1,dataw[,c("edgestr","dyadidstr",wtcols)])
dataw2$edgestr <- paste(dataw2$npi1,dataw2$npi2,sep="_")
ind <- (dataw2$edgestr %in% dataw$edgestr)
dataw2 <- dataw2[!ind,]
dataw2[,wtcols] <- 0 #Directed weights set to 0 as reverse-edge not in dataw, undirected weights imputed for reverse edges later
dataw <- rbind(dataw,dataw2)
dataw <- dataw[order(dataw$dyadidstr),]
pos1 <- seq(1,nrow(dataw),2)
pos2 <- pos1+1
dataw[pos1,wtcols[Directed==0]] <- dataw[pos1,wtcols[Directed==0]]+dataw[pos2,wtcols[Directed==0]] #sum edge-weights for undirected cases
dataw[pos2,wtcols[Directed==0]] <- dataw[pos1,wtcols[Directed==0]] #Make weights the same for edges in dyad when dyad undirected

#Merge with edges whose status is known
datadiag <- merge(keepedge,dataw[,c("npi1","npi2",wtcols)],by=c("npi1","npi2"),all.x=TRUE)
datadiag <- merge(datadiag,dataw[,c("npi1","npi2",wtcols)],by.x=c("npi1","npi2"),by.y=c("npi2","npi1"),all.x=TRUE,suffix=c("","r"))

#Generates and outputs optimal network for real-data outcome analysis in Section 7
genoptimal <- 1
if (genoptimal==1) {
 oddeven <- rep(c(1,-1),times=nrow(dataw)/2)
 obs <- 1:nrow(dataw)
 revobs <- obs+oddeven
 xsymmopt <- dataw$w7+dataw$w7[revobs]
 xdiropt <- (dataw$w17-dataw$w17[revobs])/2
 lpopt <- -3.613+0.0075*xsymmopt-0.0464*xdiropt
 dataw$wopt <- exp(lpopt)/(1+exp(lpopt))
 minupat <- min(dataw$upat) #Get same scale as undirected network
 maxupat <- max(dataw$upat)
 dataw$wopt <- minupat+(maxupat-minupat)*(dataw$wopt-min(dataw$wopt))/(max(dataw$wopt)-min(dataw$wopt))
 dataw$upat <- dataw$w30
 dataw$gvisit <- dataw$w28
 dataw$w7r <- dataw$w7[revobs]
 dataw$w17r <- dataw$w17[revobs]
 keep <- c("edgestr","npi1","npi2","upat","gvisit","w7","w7r","w17","w17r","wopt")
 write.csv(dataw[,keep],paste(outdir,"CMSOptDirTieData.csv",sep=""),row.names=FALSE) #Just for network related to Sound physicians
}
cor(dataw$upat,dataw$wopt)

#The directed shared-patient network is an edgelist; it is not padded with weights of 0 for absent edges
# Take care of this now.
rowmiss <- is.na(datadiag$w30) #These are generated because we only keep edges with npi1 in the set npiresp in keepedge
datadiag[rowmiss,c(wtcols,paste(wtcols,"r",sep=""))] <- 0

#Check if respondent who did not appear in the CMS claims named anyone in CMS claims or was named by anyone?
# If they're not named by anyone, I suggest dropping as that NPO employee may not be a physician?
nocms <- sdata[!(sdata$responding %in% u),]
nocmsname <- unique(nocms$nominee) #Physicians named by this person
table(nocmsname %in% u)
nocmsresp <- unique(nocms$responding)
table(nocmsresp %in% sdata$nominee) #Physicians who name this person: there are none

#Augment CMS data set with additional null shared patient weights and an indicator that augmented physician was not in CMS
augdata <- cbind(rep(nocmsresp,times=length(u)),u) #Additional edges with nocmsresp as namer
augdatar <- cbind(npiresp,rep(nocmsresp,times=length(npiresp)))
augdata <- data.frame(rbind(augdata,augdatar))
augdata$nocmsresp <- 1
names(augdata) <- c("npi1","npi2","nocmsresp")
augdata <- augdata[(augdata$npi1!=augdata$npi2),]
datadiag <- merge(datadiag,augdata,by=c("npi1","npi2"),all=TRUE)
ind <- is.na(datadiag$upat)
datadiag[ind,c("upat","upatdir","upatdirr","upatsame","gvisit",wtcols,paste(wtcols,"r",sep=""))] <- 0 #Decr sensitivity, Incr specificity
datadiag$nocmsresp[!ind] <- 0

tmp <- datadiag[datadiag$upat>0,c("upat","upatdir","upatdirr","upatsame","w6","w6r","w30")]
nsameday <- datadiag$w6+datadiag$w6r-datadiag$w30
tmp$nsameday <- nsameday[datadiag$upat>0]

#Checks
print('Check 1: upat and w30 should be identical; gvisit and w28 should be identical')
print(c(summary(datadiag$upat-datadiag$w30),summary(datadiag$gvisit-datadiag$w28)))
print('Check 2: Internal consistency of undirected, directed, and same-day upat variables')
print(c(summary(datadiag$upat-datadiag$upatdir-datadiag$upatdirr-datadiag$upatsame))) #Should only be positive?
print('Check 3: Check that w6 >= datadiag$upatdir, w6r >= datadiag$upatdirr')
print(table(datadiag$w6>=datadiag$upatdir,datadiag$w6r>=datadiag$upatdirr))
nsameday <- datadiag$w6+datadiag$w6r-datadiag$w30
print('Check 4: Same day visits across the two programs')
print(table(datadiag$upatsame==nsameday))
print('Check 5: w6 and its edge in the reverse direction, w6r, should satisfy w70 = 1*(w6+w6r>0)')
binupatdircheck <- 1*(datadiag$w6+datadiag$w6r>0)
print(c(summary(datadiag$w70-binupatdircheck)))
print('Check 6: upat=w30 <= w6+w6r (being equal if w6=0 or w6r=0)')
ind <- (datadiag$w6==0 | datadiag$w6r==0)
print(c(summary(datadiag$upat[ind]-datadiag$w6[ind]-datadiag$w6r[ind])))
print('Check 7: w7 and its edge in the reverse direction, w7r, should satisfy gvisit=w28 >= w7+w7r >= w30')
print(c(summary(datadiag$w7+datadiag$w7r-datadiag$w30),summary(datadiag$gvisit-datadiag$w7-datadiag$w7r)))
print('Check 8a: Confirm Chuankai ordering of visits based on order of observation in data (as no dual double counts)')
print(table(datadiag$upatdir<=datadiag$w6,datadiag$upatdirr<=datadiag$w6r)) #Use if use < in PatientSharingNew.r
print('Check 8b: Confirm Chuankai ordering of visits based on order of observation in data (as no dual double counts)')
print(table(datadiag$upatdir+datadiag$upatsame>=datadiag$w6,datadiag$upatdirr+datadiag$upatsame>=datadiag$w6r))

#### Convert NPO survey data to numerical format and merge with diagnostic data set ####

#Data dictionary of NPI matched NPO survey data
# X.1 = row number: redundant
# NPPES_name = Name in data set we looked up to identify physician's NPI number
# Nominations_name = Name of peer physician entered by survey respondent
# NPPES_NPI = NPI (national provider identification number) found in NPPES lookup. Called "nominee"
# X = Hospital ID number of nominated physician. Called "HospNomID"
# HospitalName = Hospital of respondent. Called "HospitalRespName"
# ConnectionType = Which of the four name generator questions yielded nomination. Called "ConnectType"
# specialtyColleague = Speciality of nominee. Called "SpecialtyNom"
# Responding.Physician.NPI = NPI of respondent. Called "responding"

sdata$tieid <- (10^10)*sdata$responding+sdata$nominee
ord <- order(sdata$tieid)
sdata <- sdata[ord,]
uType <- 1*(sdata$ConnectType=="InfAdviceOwnHosp")+2*(sdata$ConnectType=="ReferralOwnHosp")+3*(sdata$ConnectType=="InfAdviceOtherHosp")+4*(sdata$ConnectType=="ReferralOtherHosp")

#sdata contains the nominations in NPO (the other network) along with the specialty of the nominated physician
# It is used to form the directly measured NPO network
# It is not the entire sampling-frame

nties <- length(unique(sdata$tieid)) #Sometimes same person for multiple nomination types, reshape to have unique edges
freqr <- table(sdata$tieid)
stiedata <- matrix(0,nrow=nties,ncol=7)
rownominfo <- rep(0,nties)
pos <- 1
for (i in 1:nties) {
 stiedata[i,1:3] <- as.numeric(sdata[pos,c(7,6,1)])
 for (j in 1:freqr[i]) {
  typecol <- 3+uType[pos] 
  stiedata[i,typecol] <- 1
  if (j==1) {
   rownominfo[i] <- pos #Because ties are prioritized, we take info of first connection type to occur
  }
  pos <- pos+1
 }
}
stiedata <- data.frame(stiedata)
names(stiedata) <- c("tieid","responding","nominee","InfOwn","RefOwn","InfOth","RefOth")
stiedata$named <- 1 #Records whether Sound nomination exists
stiedata[,c("HospRespName","HospNomID","SpecialtyNom")] <- sdata[rownominfo,c(3,2,5)]
stiedata <- stiedata[,-1] #Remove tieid
stiedata <- stiedata[(stiedata$responding!=stiedata$nominee),] #Remove any self-ties

## Merge CMS claims data with survey data ##

#Nominee and responding IDs might not be in CMS data if they weren't practicing then
# Sounds status should be taken to be a non-edge if not named.
# Condition on being in CMS data for some analyses
#Merge such that npi1 is the responding physician and npi2 the nominated physician (retain directionality)
data <- merge(datadiag,stiedata,by.x=c("npi1","npi2"),by.y=c("responding","nominee"),all=TRUE)
#print(length(duplicated(data))) #Check that no duplicates!

#Clean data
#Code missing nominations as 0
ind <- is.na(data$named)
data[ind,c("InfOwn","RefOwn","InfOth","RefOth","named")] <- 0

#Physicians named who did not appear in CMS
nocmsnom <- is.na(data$upat)
data[nocmsnom,c("nocmsresp","upat","upatdir","upatsame","upatdirr","gvisit",wtcols,paste(wtcols,"r",sep=""))] <- 0 #Decr sensitivity, Incr specificity
data$nocmsnom <- 1*nocmsnom
table(data$nocmsresp,data$nocmsnom)

#Form new individual physician and dyad IDs
uphysid <- unique(c(data$npi1,data$npi2))
nphys <- length(uphysid) #Number dyads so that the first IDs are for the nominators
physid <- cbind(1:nphys,uphysid)
data$id1 <- 0; data$id2 <- 0; 
for (i in 1:nphys) {
 ind <- (data$npi1==uphysid[i])
 data$id1[ind] <- i
 ind <- (data$npi2==uphysid[i])
 data$id2[ind] <- i
}
minid <- apply(data[,c("id1","id2")],1,"min")
maxid <- apply(data[,c("id1","id2")],1,"max")
data$dyadid <- 10000*minid+maxid
ord <- order(data$dyadid)
data <- data[ord,]

print('Information on how many edges have reverse nomination status also present in data')
freqdyadid <- table(data$dyadid)
print(table(freqdyadid))

## Add additional attribute information from sampling frame (Only available for Sound physicians) ##

#Data dictionary of Sampling frame data
# hospid = Hospital ID of NPO physician. 
# NPI = Physician CMS ID
# EmploymentType = Regular (W2) or various types of Consultant (1099)
# Status = Active or not (inactive physicians already excluded)
# ColleagueType = Role (most are physician, only physicians were in survey)
# Suffix = MD or DO
# in_encounter = Flag for whether record is in encounter data?
# in_mips = Flag for whether record is in the MIPS?
# nAffils = Number of hospital affiliations
# Region = Sound Region of Country
# TeachingStatus = Teaching status of hospital
# Locality = U (urban) versus R (rural)
# Bedsize = Size of hospital as reflected by number of beds
# nSoundPhys = Number of NPO physicians at hospital
# nRegion = Numerical code for region of country
# Teaching = 1 if teaching, 0 otherwise
# Rural = 1 if rural, 0 otherwise
# Bed_Size = Numerical version of Bedsize variable
# Sampled = 1 if among 600 sampled physicians, 0 otherwise

sframe <- read.csv(paste(datdir,"SamplingFrameByHosp_21Sept19.csv",sep=""),header=TRUE)
names(sframe)[1] <- "hospid"
dup <- duplicated(sframe)
sframe <- sframe[!dup,] #Remove 1 duplicated observation from sframe; else messes up merge!
data <- merge(data,sframe,by.x="npi1",by.y="NPI",all.x=TRUE) #Change all if get more claims
data <- merge(data,sframe,by.x="npi2",by.y="NPI",all.x=TRUE,suffixes=c("1","2"))

# The following are some data checks #
Name.by.ID1 <- table(data$HospRespName,data$hospid1)
apply(Name.by.ID1>0,1,'sum') #Check that each name has a single ID
apply(Name.by.ID1>0,2,'sum') #Check that each ID has a single name. Looks good!
Name.by.ID2 <- table(data$HospRespName,data$hospid2)
apply(Name.by.ID2>0,1,'sum') #Check that each name has a single ID. They don't!
apply(Name.by.ID2>0,2,'sum') #Check that each ID has a single name. Some have none, some > 1!

#Keep just the weighted ties - removing the binary valued ties
data <- data[,-c(48:87,128:167)] #Need to check that get the correct columns wtcols <- wtcols[1:40]

## Output data for evaluating concordance of ties etc. ##
write.csv(data,paste(outdir,"ConcordanceTieData19.csv",sep=""),row.names=FALSE) #2019 data